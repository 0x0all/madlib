## \defgroup madpack MadPack
# Package manager for managing MADlib installations.
# Provides madpack command-line tool and python modules to manage multiple 
# tasks:
#   - install and build libraries in the filesystem
#   - roll forward/back database DDL to register code with database
#   - check sanity of the DB metadata vis-a-vis what the filesystem has
# Run <c>madpack -h</c> to see usage.
#
# MADPack Migrations is modeled on Django South and Rails Migrations.
# It allows rolling forward/backward across multiple versions of MADlib.
# Like those tools, we use a directory of migration scripts that provide
# code for rolling forward and backward across versions of the DB.
# But because MADlib is made up of many methods, we synthesize those scripts
# from individual scripts stored registered in the Install.yml for each
# method/port.  The MADlib Config.yml file specifies the relevant method/ports
# to install.
#
# We use two separate numbering schemes:
#  - the Migration number is a sequence number for 
#    roll-forward/rollback history on a particular DB/schema.  These 
#    numbers are auto-generated by the MadPackMigration class and
#    basically for internal use.  They are generated as dense (consecutive)
#    integers, but the important feature is that they have an order that can
#    be rolled forward/backward, which is a key of the migrationhistory table
#    in the database.
#
#  - the Version number is a MADlib release version, copied from the 
#    Version.yml file.  We assume that users will typically think in terms
#    of version numbers, though Migration numbers are exposed in case there's
#    need to fiddle with them.
#
# Migration information is stored in two places, following the design of 
# South and Rails:
#  - migration scriptfiles named <MigrationNumber>_<Version>.py are stored 
#    in a designated "scripts" directory.  Default is 
#    <python-site-packages>/madpy/config/scripts, but different script 
#    directories can be used (e.g. to support different MADlib versions in 
#    different databases or schemas).
#  - in the relevant database schema (default "madlib"), there is a table  
#    called migrationhistory that keeps track of the names of the scripts
#    installed (in order), and the dates they were installed.
# There may be migrations in the scripts directory that have not been 
# installed (or that were uninstalled).  The sanity() method below can be used
# to compare the scriptfiles against the migrationhistory table.


import os
import shutil
import sqlparse
import sys
import glob
import imp
import traceback
import hashlib
import madpy
from madpy.madpack import configyml

##
# A Python exception class for our use
class MadPackMigrationError(Exception):
    pass

##
# Main class for MadPackMigrations package
class MadPackMigration:
    ## The constructor. 
    #  @param self the object pointer 
    #  @param mig_dir the directory to use for migration files
    #  @param conf_dir the directory where Config.yml is to be found
    def __init__(self, mig_dir, conf_dir):
        ## @var conf the configuration
        self.conf = configyml.get_config(conf_dir, False)        
        api = self.conf['dbapi2']
        connect_args = self.conf['connect_args']
        dbapi2 = __import__(api, globals(), locals(), [''])

        ## @var mig_dir the directory with the migration files
        self.mig_dir = mig_dir
        ## @var mig_dir the directory with the Config.yml file
        self.conf_dir = conf_dir

        ## @var mig_number_len migration files have names of the form
        #    <mig_number>_<version_name>.py        
        # where mig_number is mig_number_len digits long
        self.mig_number_len = 3
        
        # @var mig_prolog the junk that goes at the top of each migration file
        self.mig_prolog = """#!/usr/bin/python
import sys
from madpy.madpack.migrations import MadPackMigration

class Migration(MadPackMigration):
"""

        ## @var mig_forwards_prolog the junk that goes before each method's forwards script
        self.mig_forwards_prolog = """\tdef forwards(self):\n\t\tcur = self.dbconn.cursor()\n"""

        ## @var mig_backwards_prolog the junk that goes before each method's backwards script
        self.mig_backwards_prolog = """\tdef backwards(self):\n\t\tcur = self.dbconn.cursor()\n"""
        ## @var dbconn live database connection
        con_args={};
        for arg in connect_args:
            if arg.find("=") == -1:
                print sys.exc_info()[0]
                print "Missing '=' character in the connect_args parameter: " + arg
                raise
            # cleanup the string
            arg = ((arg.replace( "'", "")).replace( '"', '')).replace( ' ', '')            
            equal_sign = arg.find('=')
            # create a proper dictionary of connection parameters
            con_args[ arg[:equal_sign]] = arg[equal_sign+1:]
        self.dbconn = dbapi2.connect( **con_args)

    ## Destructor: clean up the DB connection!
    def __del__(self):
        self.dbconn.close()
        
# MIGRATION FILE UTILITIES

    ## pad string with characters on the left
    # @param self the object
    # @param strng string to be padded
    # @param prefixchar character to pad with
    # @param number of copies
    def __pad_on_left_to_n(self,strng,prefixchar,n):
        return "".join([prefixchar for i in range(0,n - len(strng))]) + strng

    ## scan migration script names, and map versions to migration numbers
    def __map_versions_to_nums(self):
        vnmap = dict()
        migfiles = glob.glob(self.mig_dir+"/"+"".join(["[0-9]" for i in range (0,self.mig_number_len)])+"_*.py")
        for f in migfiles:
            ver = f.split("_")[1].split(".py")[0]
            mig = f.split("_")[0].split("/")[-1]
            vnmap[ver]=mig
        return vnmap

    # map a specific version v to its migration number 
    def __map_version_to_num(self, v, vnmap=None):
        if vnmap == None:
            vnmap = self.__map_versions_to_nums()
        return int(vnmap[v])
        
    # method to load migration code that we will generate.
    # from http://code.davidjanes.com/blog/2008/11/27/how-to-dynamically-load-python-code/
    def __load_module(self, code_path):
        try:
            try:
                code_dir = os.path.dirname(code_path)
                code_file = os.path.basename(code_path)

                fin = open(code_path, 'rb')
                h = hashlib.md5()
                h.update(code_path)
                return  imp.load_source(h.hexdigest(), code_path, fin)
            finally:
                try: fin.close()
                except: pass
        except ImportError, x:
            traceback.print_exc(file = sys.stderr)
            raise
        except:
            traceback.print_exc(file = sys.stderr)
            raise
    
# DB MIGRATIONHISTORY UTILITIES       
    # find current migration in database
    def __current_mig(self):
        cur = self.dbconn.cursor()
        try:
            cur.execute("SELECT migration FROM "
                        + self.conf['target_schema'] + 
                        ".migrationhistory ORDER BY id DESC LIMIT 1;")
        except:
            print sys.exc_info()[0]
            print "Unexpected error creating " \
                  + self.conf['target_schema'] + ".migrationhistory in database:"
            raise
        row = cur.fetchone()
        if row == None:
            return None
        filename = row[0]
        return filename

    def __mig_files_history(self):
        cur = self.dbconn.cursor()
        try:
            cur.execute("SELECT migration FROM "
                        + self.conf['target_schema'] + 
                        ".migrationhistory ORDER BY migration;")
        except:
            print sys.exc_info()[0]
            print "Unexpected error creating " \
                  + self.conf['target_schema'] + ".migrationhistory in database:"
            raise
        return [m[0] for m in cur.fetchall()]
        

    ## find highest-numbered migration file
    def max_file(self):
        numlist = [int(i.split('_')[0]) for i in os.listdir(self.mig_dir) if i.split('_')[0].isdigit()]
        if len(numlist) > 0:
            return max(numlist)
        else:
            return 0

    ## find current migration number registered in DB. 
    def current_mig_number(self):
        curmig = self.__current_mig()
        if curmig == None:
            return -1
        else:
            return int(curmig.split("_")[0])

    ## find current version registered in DB. 
    def current_version(self):
        curmig = self.__current_mig()
        if curmig == None:
            return None
        else:
            return self.__current_mig().split("_")[1].split(".py")[0]

    ## list migration files (lo to hi) whose number is > start
    # @param start lower-bound (non-inclusive) defaults to current DB-installed migration number
    def fw_files(self, start = None):
        if not start:
            start = self.current_mig_number()
        files = [i for i in os.listdir(self.mig_dir) if i.split('_')[0].isdigit() and int(i.split('_')[0]) > start and i.split(".")[-1] == "py"]
        files.sort()
        return files

    ## list migration files (hi to lo) whose number is <= start
    # @param start upper-bound (inclusive) defaults to current DB-installed migration number
    def bw_files(self, start = None):
        if not start:
            start = self.current_mig_number()
        files = [i for i in os.listdir(self.mig_dir) if i.split('_')[0].isdigit() and int(i.split('_')[0]) <= start and i.split(".")[-1] == "py"]
        files.sort(reverse=True)
        return files

    ## extract version from migration filename
    # @param self the object
    # @param fname a migration file name
    def version(self, fname):
        return fname.split("_")[1].split(".py")[0]

    ## extract migration number from migration filename
    # @param self the object
    # @param fname a migration file name
    def mig_num(self, fname):
        return fname.split("_")[0]

    ## generate migration filename from version and migration number
    # @param self the object
    # @param version a MADlib version string
    # @param mig_num a MADpack migration number
    def migfile(self, version, mig_num):
        name = self.__pad_on_left_to_n(str(mig_num), "0", self.mig_number_len) + "_" + version
        if name.split('.')[-1] != "py":
            name += ".py"
        return name 

    ## generate a new migration filename, with number one larger than max
    # @param self the object
    # @param name a string for a filename; typically a version string
    def __gen_filename(self, name):
        next_num = self.current_mig_number()+1
        return self.migfile(name, next_num)

    ## do a shallow parse of an SQL file, and wrap each stmt with 
    ## Python dbapi2 call syntax.
    # @param self the object
    # @param sqlfile filename containing SQL commands
    # @param indent_width Python indentation width
    def __wrap_sql(self,sqlfile,indent_width):
        fd = open(sqlfile)
        sqltext = "".join(fd.readlines())
        stmts = sqlparse.split(sqltext)
        retval = ""
        for s in stmts:
            if s.strip() != "":
                retval += "".join(["\t" for i in range(0,indent_width)]) + "cur.execute(\"\"\"" + s.strip() + "\"\"\")"
                retval += "\n"
        return retval

    ## generate a new migration file and place in dir
    # @param self the object
    # @param dir directory to place the output file
    # @param name version string to be used in file name
    # @param upfiles list of SQL files for roll-forward migration
    # @param downfiles list of SQL files for roll-back migration
    def generate(self, dir, name, upfiles, downfiles):
        self.setup()
        filename = self.__gen_filename(name)
        # while os.path.exists(dir + filename)
        fd = open(dir + "/" + filename, 'w')
        fd.write(self.mig_prolog)
        fd.write(self.mig_forwards_prolog)
        for f in upfiles:
            fd.write(self.__wrap_sql(f,2))
        fd.write("\n\n\n")
        fd.write(self.mig_backwards_prolog)
        for f in downfiles:
            fd.write(self.__wrap_sql(f,2))
        return filename
        
    ## create migrations directory and metadata in DB.
    # schema is:
    #    id:          serial
    #    migration:   varchar(255)
    #    applied:     timestamp with time zone
    def setup(self):
        cur = self.dbconn.cursor()
        try:
            cur.execute("""SELECT table_schema, table_name
                             FROM information_schema.tables
                            WHERE table_schema = %s
                              AND table_name = 'migrationhistory';""",
                        (self.conf['target_schema'],))
        except:
            raise MadPackMigrationError("Unexpected error checking " 
                                        + self.conf['target_schema'] + 
                                        + " schema in database")
            
        if cur.fetchone() == None:
            # check for schema
            cur.close()
            cur = self.dbconn.cursor()
            try:
                cur.execute("""SELECT * FROM information_schema.schemata
                                WHERE schema_name = %s;""", 
                            (self.conf['target_schema'],))
            except:
                print sys.exc_info()[0]
                print "Unexpected error checking "+self.conf['target_schema']+" schema in database:"
                raise
            if cur.fetchone() == None:
                print sys.exc_info()[0]
                raise MadPackMigrationError("%s schema not defined in database", (self.conf['target_schema'],))
            cur.close()
            cur = self.dbconn.cursor()
            try:
                cur.execute("CREATE TABLE " + self.conf['target_schema'] + 
                            ".migrationhistory (id serial, \
                             migration varchar(255),\
                             applied timestamp with time zone)")
            except:
                print sys.exc_info()[0]
                print "Unexpected error creating madlib.migrationhistory in database:"
                raise
            cur.close()
            self.dbconn.commit()

    ## record the application of a forward migration in migrationhistory table
    def record_migration(self, filename):
        cur = self.dbconn.cursor()
        try:
            cur.execute("INSERT INTO " + self.conf['target_schema'] + 
                        ".migrationhistory (migration, applied) VALUES (%s, now());", (filename,))
        except:
            print sys.exc_info()[0]
            raise #MadPackMigrationError("Unexpected error recording into madlib.migrationhistory in database:")
        return True

    ## remove entry for a migration matching filename
    def delete_migration(self, filename):
        cur = self.dbconn.cursor()
        try:
            cur.execute("DELETE FROM " + self.conf['target_schema'] +               
                        ".migrationhistory WHERE migration = %s;",
                        (filename,))
        except:
            print sys.exc_info()[0]
            print "Unexpected error deleting from " + \
                  self.conf['target_schema']+".migrationhistory in database:"
            raise
        return True
        
    ## roll migrations fw/bw from current to desired.
    # desire can be expressed by migration number or by version 
    # (but not both.)
    # there has to be a pre-existing migration script that matches.
    # @param mignumber migration number to roll to
    # @param migversion version number to roll to
    def migrate(self, mignumber=None, migversion=None):
       print "Running DB migartion:"
       connect_args=self.conf['connect_args'], 
       api = self.conf['dbapi2']
       if mignumber and migversion:
           raise MadPackMigrationError("more than one of {num,version} passed to migrate")
       if migversion:
           mignumber = self.__map_version_to_num(migversion)
       cur = self.current_mig_number()
       maxfile = self.max_file()
       if maxfile == None:
           return
       if mignumber == None:
           mignumber = maxfile
       if mignumber > maxfile:
           print sys.exc_info()[0]
           raise MadPackMigrationError("migration number " + str(mignumber) + " is larger than max file number " + str(maxfile))
       if cur == None or mignumber > cur:
           files = [f for f in self.fw_files() if int(f.split("_")[0]) <= mignumber]
           if len(files) > 0:
               print "- migrating forwards to " + files[-1]
           # rolling fw
           for f in files:
               num = int(f.split("_")[0])
               print "> " + f
               mod = self.__load_module(self.mig_dir+"/"+f)
               m = mod.Migration(self.mig_dir, self.conf_dir)
               m.forwards()
               m.record_migration(f)
               m.dbconn.commit()
       elif mignumber < cur:
           # rolling bw
           files = [f for f in self.bw_files() if int(f.split("_")[0]) > mignumber]
           if len(files) > 0:
               print "- migrating backwards to before " + files[-1]
           for f in files:
               num = int(f.split("_")[0])
               print "> " + f
               mod = self.__load_module(self.mig_dir+"/"+f)
               m = mod.Migration(self.mig_dir, self.conf_dir)
               m.backwards()
               m.delete_migration(f)
               m.dbconn.commit()
                   
    ## make sure script directory and migrationhistory match
    def sanity(self):
       okflag = True
       migfiles = [f.split("/")[-1] for f in \
                   glob.glob(self.mig_dir +"/" +
                             "".join(["[0-9]" for i in \
                                    range(0,self.mig_number_len)])+"_*.py")]
       if not os.path.exists(self.mig_dir + "/Config.yml"):
           print "Config.yml missing from script directory; exiting"
           exit(2)
       history = self.__mig_files_history()
       if self.mig_dir != self.conf_dir:
           testconf = configyml.get_config(self.mig_dir, False)
           if testconf != self.conf:
               print "cached " + self.mig_dir + \
                     "/Config.yml does not match " + \
                     self.conf_dir + "/Config.yml"
               okflag = False
           else:
               print "cached Config.yml matches " +\
               self.conf_dir + "/Config.yml"
       for m in migfiles:
           if m not in history:
               print "< file " + m + " not reflected in migration history"
               okflag = False
       for h in history:
           if h not in migfiles:
               print "> file " + h + " of migration history missing from script directory"
               okflag = False
       if not okflag:
           print "scripts: " + str(migfiles)
           print "history: " + str(history)
           exit(2)
       else:
           print "scriptdir matches migration history"

