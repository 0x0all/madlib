/* ----------------------------------------------------------------------- *//** 
 *
 * @file kmeans.sql_in
 *
 * @brief SQL functions for k-means clustering
 * @date January 2011
 *
 * @sa For a brief introduction to k-means clustering, see the module
 *     description \ref grp_kmeans.
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_kmeans 

@about

K-means clustering algorithm divides a list of objects 
into K groups based on the similarity of their attributes. 

Both objects and groups are represented as points in n-dimensional 
space. The similarity is expressed as distance between objects (points) and
group centers (centroids). Each object is assigned to a group with 
the nearest centroid in a series of iterations, the goal of which is
to minimize the total distance between points and their centroids. 
The distance is currently measured using l2-norm, 
also know as
<a href="http://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm">Euclidean
distance</a>.


This method works on a set of data points accessible in a table or through a view. 
Initial centroids are found according to k-means++ algorithm [1]. 
Further adjustments are based on the Euclidean distance between 
the current centroids and all available data points or a random subset of them
, such that there are at least 200 points from each initial cluster.

The algorithm stops when one of the following conditions is met:
- fraction of reassigned nodes is not growing
- fraction of reassigned nodes is smaller than the limit (default = 0.001)
- reached the maximum number of allowed iterations (default = 20)

Goodness of fit measure (calculated on demand) is derived in the following way:
...


@input
The <strong>input table</strong> is expected to be of the following form:
<pre>{TABLE|VIEW} <em>input_table</em> (
    ...
    <em>pid</em> (optional) INTEGER,
    <em>position</em> INTEGER[]|SVEC|FLOAT[],
    ...
)</pre>
where: 
    - <em>pid</em> is the name of an optional column with an ID of the data point
    - <em>position</em> contains the coordinates of the data point which can be of either \c INT[], \c SVEC or \c FLOAT[]

@usage
- The K-means function is called by:
<pre>SELECT \ref kmeans( '<em>input_table</em>', <em>k</em>,
   '<em>goodness</em>', '<em>run_id</em>', '<em>output_schema</em>');</pre>
- The centroid locations are stored in <tt>kmeans_out_centroids_(<em>run_id</em>)</tt>:
<pre>
 cid |  position                   
-----+-------------
...
</pre>
- The cluster assignments for each input data point are stored in <tt>kmeans_out_points_(<em>run_id</em>)</tt>:
<pre>
 pid |  position  | cid 
-----+------------+-----
...
</pre>

@examp

-#  Prepare the input table/view with the required structure.
\code
sql> SELECT * FROM data;
 pid |                position                
-----+----------------------------------------
   1 | {0.0718717803247273,0.681504756677896}
   2 | {0.560906498227268,0.911145981866866}
   3 | {0.0835227882489562,0.716428406536579}
   4 | {0.569831892382354,0.268620396964252}
   5 | {0.425952713936567,0.713892595842481}
   6 | {0.507394600193948,0.345010714139789}
   ...
\endcode    
-#  Call kmeans():
\code
sql> select MADLIB_SCHEMA.kmeans( 
'data', 10, 1, 'testrun', 'MADLIB_SCHEMA');
\endcode
-# Sample output:
\code
INFO: Started kmeans with parameters:
INFO:  * k = 10 (number of centroids)
INFO:  * input_table = madlib.data
INFO:  * goodness = 1 (GOF test on)
INFO:  * run_id = testrun
INFO:  * output_schema = madlib
INFO: Seeding 10 centroids...
INFO: Using full set for analysis... (100 points)
INFO: ...Iteration 1
INFO: ...Iteration 2
INFO: Exit reason: fraction of reassigned nodes is smaller than the limit: 0.001
INFO: Expanding cluster assignment to all points...
INFO: Calculating goodness of fit...
                            kmeans                            
--------------------------------------------------------------
                                                              
 K-Means Clustering has completed.                            
 Parameters:                                                  
  - k = 10 (number of centroids)                              
  - input_table = "madlib"."data"                             
  - goodness = 1 (GOF test on/off)                            
  - run_id = testrun                                          
  - output_schema = madlib                                    
 Results:                                                     
  - analysis based on full data set (100 points)              
  - generated 10 centroids (goodness of fit = 0.114197024061) 
  - table: "madlib"."kmeans_out_centroids_testrun"            
  - table: "madlib"."kmeans_out_points_testrun"               
 Time elapsed: 0 minutes 0.947630 seconds.                    
\endcode

@literature

[1] Wikipedia, K-means++,
    http://en.wikipedia.org/wiki/K-means%2B%2B
	

@sa File kmeans.sql_in documenting the SQL functions.

@internal
@sa namespace kmeans (documenting the implementation in Python)
@endinternal
*/

/**
 * @internal
 * Support function: takes a single SVEC (A) and an ordered array of SVECs (B)
 * and returns the index of (B) with the shortest distance to (A).
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.internal_kmeans_closest_center( 
    p_point         MADLIB_SCHEMA.SVEC
    , p_centroids   MADLIB_SCHEMA.SVEC[]
    , p_dist_metric TEXT
) 
RETURNS INTEGER
AS $$
DECLARE
    min_cid         INTEGER := 1;
    min_val         FLOAT := NULL;
    temp_val        FLOAT;
BEGIN

    -- Validate: p_point, p_centroids
    IF p_point is NULL or p_centroids is NULL or p_dist_metric is NULL THEN
        RETURN null;
    END IF;

    --
    -- Loop over all centroids
    --
    -- Implementation comment:
    -- IF statement is outside the loop in order to have a static SQL call to
    -- the distance function. This is in turn required to avoid SVEC parameters
    -- serialization.
    IF p_dist_metric = 'l1norm' THEN
        FOR i IN 1..array_upper( p_centroids, 1) LOOP        
            temp_val := MADLIB_SCHEMA.l1norm( p_point, p_centroids[i]);
            IF ( temp_val < coalesce( min_val, temp_val + 1.0) ) THEN
                min_val := temp_val;
                min_cid := i;
            END IF;
        END LOOP;
    ELSIF p_dist_metric = 'l2norm' THEN
        FOR i IN 1..array_upper( p_centroids, 1) LOOP        
            temp_val := MADLIB_SCHEMA.l2norm( p_point, p_centroids[i]);
            IF ( temp_val < coalesce( min_val, temp_val + 1.0) ) THEN
                min_val := temp_val;
                min_cid := i;
            END IF;
        END LOOP;
    ELSIF p_dist_metric = 'cosine' THEN
        FOR i IN 1..array_upper( p_centroids, 1) LOOP 
            temp_val := acos( MADLIB_SCHEMA.cosine( p_point, p_centroids[i]));
            IF ( temp_val < coalesce( min_val, temp_val + 1.0) ) THEN
                min_val := temp_val;
                min_cid := i;
            END IF;
        END LOOP;
    ELSIF p_dist_metric = 'tanimoto' THEN
        FOR i IN 1..array_upper( p_centroids, 1) LOOP        
            temp_val := acos( MADLIB_SCHEMA.tanimoto( p_point, p_centroids[i]));
            IF ( temp_val < coalesce( min_val, temp_val + 1.0) ) THEN
                min_val := temp_val;
                min_cid := i;
            END IF;
        END LOOP;
    ELSE
        RAISE EXCEPTION 'Unknown distance function: %', p_dist_metric;
    END IF;            
    
    RETURN min_cid;
END
$$ LANGUAGE plpgsql STRICT;

/**
 * @internal
 * @brief Data domain for goodness of fit: <0.0,1.0>
 */
CREATE DOMAIN MADLIB_SCHEMA.gof AS FLOAT
CHECK(
   ( VALUE >= 0.0 AND VALUE <= 1.0 )
   OR VALUE is NULL
);

/**
 * @internal
 * @brief Data domain for percent: <0.0,100.0>
 */
CREATE DOMAIN MADLIB_SCHEMA.percent AS FLOAT
CHECK(
   VALUE >= 0.0 AND VALUE <= 100.0
);

/**
 * @internal
 * @brief Kmeans result data type
 */
DROP TYPE IF EXISTS MADLIB_SCHEMA.kmeans_result;
CREATE TYPE MADLIB_SCHEMA.kmeans_result AS (
    src_relation    TEXT,
    point_count     BIGINT,
    init_cset_rel   TEXT,
    init_k          INT,
    init_method     TEXT,
    dist_metric     TEXT,
    iterations      INT,
    final_k         BIGINT,
    gof             MADLIB_SCHEMA.gof,
    out_points      TEXT,
    out_centorids   TEXT
);

/**
 * @brief Compute a k-means clustering
 *
 * @param src_relation Name of relation containing the input data 
 * @param src_col_data Name of the column containing the point coordinates 
 * @param src_col_id Name of the column containing the point ids (optional)
 * @param k Number of centroids to generate
 * @param max_iter Maximum number of iterations 
 * @param gof Goodness of fit test flag 
 * @param out_points Output relation for point/centroids assignments
 * @param out_centroids Output relation for list of centroids 
 * @param overwrite Overwrite target relations (if exist)
 * @param verbose Generate detailed info during execution.
 * @return kmeans_result Summary result set
 *
 * @internal
 * @sa This function is a wrapper for kmeans::kmeans()
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.kmeans( 
  src_relation      TEXT
  , src_col_data    TEXT
  , src_col_id      TEXT
  , init_cset_rel   TEXT
  , init_cset_col   TEXT
  , k               INT 
  , init_method     TEXT /* random, kmeans++ */
  , dist_metric     TEXT /* euclidean/l2norm, manhattan/l1norm, cosine, tanimoto */
  , max_iter        INT
  , conv_threshold  FLOAT
  , gof             BOOLEAN 
  , out_points      TEXT 
  , out_centroids   TEXT
  , overwrite       BOOLEAN
  , verbose         BOOLEAN
) 
RETURNS MADLIB_SCHEMA.kmeans_result
AS $$

    PythonFunctionBodyOnly(`kmeans', `kmeans')
    
    # MADlibSchema comes from PythonFunctionBodyOnly
    return kmeans.kmeans( 
        MADlibSchema
        , src_relation, src_col_data, src_col_id
        , init_cset_rel, init_cset_col
        , k, init_method, dist_metric
        , max_iter, conv_threshold, gof
        , out_points, out_centroids, overwrite
        , verbose
    );

$$ LANGUAGE plpythonu;
