-- @namespace sparse_vectors
-- DROP SCHEMA MADLIB_SCHEMA CASCADE;
CREATE SCHEMA MADLIB_SCHEMA;

DROP TYPE IF EXISTS MADLIB_SCHEMA.svec CASCADE;
CREATE TYPE MADLIB_SCHEMA.svec;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_in(cstring)
    RETURNS MADLIB_SCHEMA.svec
    AS 'gp_svec.so'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_out(MADLIB_SCHEMA.svec)
    RETURNS cstring
    AS 'gp_svec.so'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_recv(internal)
    RETURNS MADLIB_SCHEMA.svec
    AS 'gp_svec.so'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_send(MADLIB_SCHEMA.svec)
    RETURNS bytea
    AS 'gp_svec.so'
    LANGUAGE C IMMUTABLE STRICT;

CREATE TYPE MADLIB_SCHEMA.svec (
       internallength = VARIABLE, 
       input = MADLIB_SCHEMA.svec_in,
       output = MADLIB_SCHEMA.svec_out,
       send = MADLIB_SCHEMA.svec_send,
       receive = MADLIB_SCHEMA.svec_recv,
       storage=EXTENDED,
       alignment = double
);

-- Basic floating point scalar operators MIN,MAX
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dmin(float8,float8) RETURNS float8 AS 'gp_svec.so', 'float8_min' LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dmax(float8,float8) RETURNS float8 AS 'gp_svec.so', 'float8_max' LANGUAGE C IMMUTABLE; 

-- Aggregate related functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_count(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec 
AS 'gp_svec.so', 'svec_count' STRICT LANGUAGE C IMMUTABLE; 

-- Scalar operator functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_plus(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_plus' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_minus(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_minus' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.log(MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_log' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_div(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_div' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_mult(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_mult' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_pow(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_pow' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_eq(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS boolean AS 'gp_svec.so', 'svec_eq' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_eq(float8[],float8[]) RETURNS boolean AS 'gp_svec.so', 'float8arr_equals' LANGUAGE C IMMUTABLE;

-- Permutation of float8[] and svec for basic functions minus,plus,mult,div
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_minus_float8arr(float8[],float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_minus_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_minus_svec(float8[],MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_minus_svec' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_minus_float8arr(MADLIB_SCHEMA.svec,float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_minus_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_plus_float8arr(float8[],float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_plus_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_plus_svec(float8[],MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_plus_svec' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_plus_float8arr(MADLIB_SCHEMA.svec,float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_plus_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_mult_float8arr(float8[],float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_mult_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_mult_svec(float8[],MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_mult_svec' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_mult_float8arr(MADLIB_SCHEMA.svec,float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_mult_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_div_float8arr(float8[],float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_div_float8arr' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_div_svec(float8[],MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'float8arr_div_svec' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_div_float8arr(MADLIB_SCHEMA.svec,float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_div_float8arr' LANGUAGE C IMMUTABLE;

-- Vector operator functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dot(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'svec_dot' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dot(float8[],float8[]) RETURNS float8 AS 'gp_svec.so', 'float8arr_dot' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dot(MADLIB_SCHEMA.svec,float8[]) RETURNS float8 AS 'gp_svec.so', 'svec_dot_float8arr' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dot(float8[],MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'float8arr_dot_svec' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.l2norm(MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'svec_l2norm' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.l2norm(float8[]) RETURNS float8 AS 'gp_svec.so', 'float8arr_l2norm' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.l1norm(MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'svec_l1norm' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.l1norm(float8[]) RETURNS float8 AS 'gp_svec.so', 'float8arr_l1norm' STRICT LANGUAGE C IMMUTABLE; 

-- Unnest an svec into a table of uncompressed values  
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.unnest(MADLIB_SCHEMA.svec) RETURNS setof float8  AS 'gp_svec.so', 'svec_unnest' LANGUAGE C IMMUTABLE; 

-- Appends an element to the back of an svec
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vec_pivot(MADLIB_SCHEMA.svec,float8) RETURNS MADLIB_SCHEMA.svec  AS 'gp_svec.so', 'svec_pivot' LANGUAGE C IMMUTABLE; 

-- Sums the elements of an svec/float8[]
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vec_sum(MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'svec_summate' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vec_sum(float8[]) RETURNS float8 AS 'gp_svec.so', 'float8arr_summate' STRICT LANGUAGE C IMMUTABLE; 

-- Computes the median element of an svec/float8[]
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vec_median(float8[]) RETURNS float8 AS 'gp_svec.so', 'float8arr_median' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vec_median(MADLIB_SCHEMA.svec) RETURNS float8 AS 'gp_svec.so', 'svec_median' STRICT LANGUAGE C IMMUTABLE; 

-- Casts and transforms
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_int2(int2) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_int2' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_int4(int4) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_int4' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_int8(bigint) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_int8' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_float4(float4) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_float4' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_float8(float8) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_float8' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_numeric(numeric) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_numeric' STRICT LANGUAGE C IMMUTABLE; 

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_int2(int2) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_int2' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_int4(int4) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_int4' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_int8(bigint) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_int8' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_float4(float4) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_float4' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_float8(float8) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_float8' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.float8arr_cast_numeric(numeric) RETURNS float8[] AS 'gp_svec.so', 'float8arr_cast_numeric' STRICT LANGUAGE C IMMUTABLE; 

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_cast_float8arr(float8[]) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_cast_float8arr' STRICT LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_return_array(MADLIB_SCHEMA.svec) RETURNS float8[] AS 'gp_svec.so', 'svec_return_array' LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_concat(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_concat' LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_concat_replicate(int4,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_concat_replicate' LANGUAGE C IMMUTABLE; 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.dimension(MADLIB_SCHEMA.svec) RETURNS integer AS 'gp_svec.so', 'svec_dimension' LANGUAGE C IMMUTABLE; 

-- Higher-order functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_lapply(text,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_lapply' LANGUAGE C IMMUTABLE;

-- svec access and modification functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_append(MADLIB_SCHEMA.svec,float8,int8) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_append' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_proj(MADLIB_SCHEMA.svec,int4) RETURNS float8 AS 'gp_svec.so', 'svec_proj' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_subvec(MADLIB_SCHEMA.svec,int4,int4) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_subvec' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_reverse(MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_reverse' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_change(MADLIB_SCHEMA.svec,int4,MADLIB_SCHEMA.svec) RETURNS MADLIB_SCHEMA.svec AS 'gp_svec.so', 'svec_change' LANGUAGE C IMMUTABLE;

-- Sparse Feature Vector (text processing) related functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.gp_extract_feature_histogram(text[], text[]) RETURNS MADLIB_SCHEMA.svec 
AS 'gp_svec.so', 'gp_extract_feature_histogram' LANGUAGE C IMMUTABLE; 


DROP OPERATOR IF EXISTS || ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS - ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS + ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS / ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS %*% ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS * ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS ^ ( MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);


CREATE OPERATOR || (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_concat
);

CREATE OPERATOR - (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_minus
);
CREATE OPERATOR + (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_plus
);
CREATE OPERATOR / (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_div
);
CREATE OPERATOR %*% (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.dot
);
CREATE OPERATOR * (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_mult
);
CREATE OPERATOR ^ (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.svec_pow
);

-- float8[] operators
DROP OPERATOR IF EXISTS = ( float8[], float8[]);
DROP OPERATOR IF EXISTS %*% ( float8[], MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS %*% ( MADLIB_SCHEMA.svec, float8[]);
DROP OPERATOR IF EXISTS %*% ( float8[], float8[]);
DROP OPERATOR IF EXISTS - ( float8[], float8[]);
DROP OPERATOR IF EXISTS + ( float8[], float8[]);
DROP OPERATOR IF EXISTS * ( float8[], float8[]);
DROP OPERATOR IF EXISTS / ( float8[], float8[]);
DROP OPERATOR IF EXISTS - ( float8[], MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS + ( float8[], MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS * ( float8[], MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS / ( float8[], MADLIB_SCHEMA.svec);
DROP OPERATOR IF EXISTS - ( MADLIB_SCHEMA.svec, float8[]);
DROP OPERATOR IF EXISTS + ( MADLIB_SCHEMA.svec, float8[]);
DROP OPERATOR IF EXISTS * ( MADLIB_SCHEMA.svec, float8[]);
DROP OPERATOR IF EXISTS / ( MADLIB_SCHEMA.svec, float8[]);

CREATE OPERATOR = (
	leftarg = float8[], 
	rightarg = float8[], 
	procedure = MADLIB_SCHEMA.float8arr_eq,
	commutator = = ,
--	negator = <> ,
	restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR %*% (
	LEFTARG = float8[],
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.dot
);
CREATE OPERATOR %*% (
	LEFTARG = float8[],
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.dot
);
CREATE OPERATOR %*% (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.dot
);
CREATE OPERATOR - (
	LEFTARG = float8[],
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.float8arr_minus_float8arr
);
CREATE OPERATOR + (
	LEFTARG = float8[],
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.float8arr_plus_float8arr
);
CREATE OPERATOR * (
	LEFTARG = float8[],
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.float8arr_mult_float8arr
);
CREATE OPERATOR / (
	LEFTARG = float8[],
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.float8arr_div_float8arr
);

CREATE OPERATOR - (
	LEFTARG = float8[],
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.float8arr_minus_svec
);
CREATE OPERATOR + (
	LEFTARG = float8[],
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.float8arr_plus_svec
);
CREATE OPERATOR * (
	LEFTARG = float8[],
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.float8arr_mult_svec
);
CREATE OPERATOR / (
	LEFTARG = float8[],
	RIGHTARG = MADLIB_SCHEMA.svec,
	PROCEDURE = MADLIB_SCHEMA.float8arr_div_svec
);

CREATE OPERATOR - (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.svec_minus_float8arr
);
CREATE OPERATOR + (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.svec_plus_float8arr
);
CREATE OPERATOR * (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.svec_mult_float8arr
);
CREATE OPERATOR / (
	LEFTARG = MADLIB_SCHEMA.svec,
	RIGHTARG = float8[],
	PROCEDURE = MADLIB_SCHEMA.svec_div_float8arr
);

DROP CAST IF EXISTS (int2 AS MADLIB_SCHEMA.svec) ;
DROP CAST IF EXISTS (integer AS MADLIB_SCHEMA.svec) ;
DROP CAST IF EXISTS (bigint AS MADLIB_SCHEMA.svec) ;
DROP CAST IF EXISTS (float4 AS MADLIB_SCHEMA.svec) ;
DROP CAST IF EXISTS (float8 AS MADLIB_SCHEMA.svec) ;
DROP CAST IF EXISTS (numeric AS MADLIB_SCHEMA.svec) ;

CREATE CAST (int2 AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_int2(int2) AS IMPLICIT;
CREATE CAST (integer AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_int4(integer) AS IMPLICIT;
CREATE CAST (bigint AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_int8(bigint) AS IMPLICIT;
CREATE CAST (float4 AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_float4(float4) AS IMPLICIT;
CREATE CAST (float8 AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_float8(float8) AS IMPLICIT;
CREATE CAST (numeric AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_numeric(numeric) AS IMPLICIT;

DROP CAST IF EXISTS (int2 AS float8[]) ;
DROP CAST IF EXISTS (integer AS float8[]) ;
DROP CAST IF EXISTS (bigint AS float8[]) ;
DROP CAST IF EXISTS (float4 AS float8[]) ;
DROP CAST IF EXISTS (float8 AS float8[]) ;
DROP CAST IF EXISTS (numeric AS float8[]) ;

-- CREATE CAST (int2 AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_int2(int2) AS IMPLICIT;
-- CREATE CAST (integer AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_int4(integer) AS IMPLICIT;
-- CREATE CAST (bigint AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_int8(bigint) AS IMPLICIT;
-- CREATE CAST (float4 AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_float4(float4) AS IMPLICIT;
-- CREATE CAST (float8 AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_float8(float8) AS IMPLICIT;
-- CREATE CAST (numeric AS float8[]) WITH FUNCTION MADLIB_SCHEMA.float8arr_cast_numeric(numeric) AS IMPLICIT;

DROP CAST IF EXISTS (MADLIB_SCHEMA.svec AS float8[]) ;
DROP CAST IF EXISTS (float8[] AS MADLIB_SCHEMA.svec) ;

CREATE CAST (MADLIB_SCHEMA.svec AS float8[]) WITH FUNCTION MADLIB_SCHEMA.svec_return_array(MADLIB_SCHEMA.svec) AS IMPLICIT;
CREATE CAST (float8[] AS MADLIB_SCHEMA.svec) WITH FUNCTION MADLIB_SCHEMA.svec_cast_float8arr(float8[]) AS IMPLICIT;

DROP OPERATOR IF EXISTS = (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) ;


CREATE OPERATOR = (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_eq,
	commutator = = ,
--	negator = <> ,
	restrict = eqsel, join = eqjoinsel
);

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.sum(MADLIB_SCHEMA.svec);
CREATE AGGREGATE MADLIB_SCHEMA.sum (MADLIB_SCHEMA.svec) (
	SFUNC = MADLIB_SCHEMA.svec_plus,
	PREFUNC = MADLIB_SCHEMA.svec_plus,
	INITCOND = '{1}:{0.}', -- Zero
	STYPE = MADLIB_SCHEMA.svec
);

-- Aggregate that provides a tally of nonzero entries in a list of vectors
DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.vec_count_nonzero(MADLIB_SCHEMA.svec);
CREATE AGGREGATE MADLIB_SCHEMA.vec_count_nonzero (MADLIB_SCHEMA.svec) (
	SFUNC = MADLIB_SCHEMA.svec_count,
	PREFUNC = MADLIB_SCHEMA.svec_plus,
 	INITCOND = '{1}:{0.}', -- Zero
	STYPE = MADLIB_SCHEMA.svec
);

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.array_agg(float8);
CREATE AGGREGATE MADLIB_SCHEMA.array_agg (float8) (
	SFUNC = MADLIB_SCHEMA.vec_pivot,
	PREFUNC = MADLIB_SCHEMA.svec_concat,
	STYPE = MADLIB_SCHEMA.svec
);

DROP AGGREGATE IF EXISTS MADLIB_SCHEMA.median_inmemory(float8);
CREATE AGGREGATE MADLIB_SCHEMA.median_inmemory (float8) (
	SFUNC = MADLIB_SCHEMA.vec_pivot,
	PREFUNC = MADLIB_SCHEMA.svec_concat,
	FINALFUNC = MADLIB_SCHEMA.vec_median,
	STYPE = MADLIB_SCHEMA.svec
);

-- Comparisons based on L2 Norm
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_lt(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_lt' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_le(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_le' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_eq(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_eq' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_ne(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_ne' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_gt(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_gt' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_ge(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS bool AS 'gp_svec.so', 'svec_l2_ge' LANGUAGE C IMMUTABLE;
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.svec_l2_cmp(MADLIB_SCHEMA.svec,MADLIB_SCHEMA.svec) RETURNS integer AS 'gp_svec.so', 'svec_l2_cmp' LANGUAGE C IMMUTABLE;

DROP OPERATOR IF EXISTS < (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) CASCADE ;
DROP OPERATOR IF EXISTS <= (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) CASCADE ;
DROP OPERATOR IF EXISTS <> (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) ;
DROP OPERATOR IF EXISTS == (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) CASCADE ;
DROP OPERATOR IF EXISTS > (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) CASCADE ;
DROP OPERATOR IF EXISTS >= (MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec) CASCADE ;
DROP OPERATOR IF EXISTS *|| (int4, MADLIB_SCHEMA.svec) ;

CREATE OPERATOR < (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_lt,
	commutator = > , negator = >= ,
	restrict = scalarltsel, join = scalarltjoinsel
);
CREATE OPERATOR <= (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_le,
	commutator = >= , negator = > ,
	restrict = scalarltsel, join = scalarltjoinsel
);
CREATE OPERATOR <> (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_eq,
	commutator = <> ,
	negator = =,
	restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR == (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_eq,
	commutator = = ,
	negator = <> ,
	restrict = eqsel, join = eqjoinsel
);
CREATE OPERATOR >= (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_ge,
	commutator = <= , negator = < ,
	restrict = scalargtsel, join = scalargtjoinsel
);
CREATE OPERATOR > (
	leftarg = MADLIB_SCHEMA.svec, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_l2_gt,
	commutator = < , negator = <= ,
	restrict = scalargtsel, join = scalargtjoinsel
);

CREATE OPERATOR *|| (
	leftarg = int4, rightarg = MADLIB_SCHEMA.svec, procedure = MADLIB_SCHEMA.svec_concat_replicate
);

CREATE OPERATOR CLASS MADLIB_SCHEMA.svec_l2_ops
DEFAULT FOR TYPE MADLIB_SCHEMA.svec USING btree AS
OPERATOR        1       < ,
OPERATOR        2       <= ,
OPERATOR        3       == ,
OPERATOR        4       >= ,
OPERATOR        5       > ,
FUNCTION        1       MADLIB_SCHEMA.svec_l2_cmp(MADLIB_SCHEMA.svec, MADLIB_SCHEMA.svec);

