--------------------------------------------------------------------------------
-- MADlib K-Means Clustering:
-- DB Migration >> create script
--------------------------------------------------------------------------------

--! @file kmeans_create.sql_in
--!
--! Database objects for k-means clustering

BEGIN;

--! Support function: takes a single SVEC (A) and an array of SVECs (B)
--! and returns the index of (B) with the shortest distance to (A).
--!
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA._kmeans_closestID( 
    p_point MADLIB_SCHEMA.SVEC, p_centroids MADLIB_SCHEMA.SVEC[]
) 
RETURNS INTEGER
AS $$
DECLARE
    minCID      INTEGER := 1;
    min_val     FLOAT;
    temp_val    FLOAT;
BEGIN

    -- Check the arguments
    IF p_point is NULL or p_centroids is NULL THEN
        RETURN null;
    END IF;

    min_val = l2norm( p_point - p_centroids[1]);

    FOR i IN 2..array_upper( p_centroids, 1) 
    LOOP
        temp_val = l2norm( p_point - p_centroids[i]);
        IF ( temp_val < coalesce( min_val, temp_val + 1) ) THEN
            min_val = temp_val;
            minCID = i;
        END IF;
    END LOOP;
    
    RETURN minCID;
END
$$ LANGUAGE plpgsql;

--! Finalize function for _kmeans_meanPosition() aggregate.
--!
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA._kmeans_mean_finalize( p_centroid MADLIB_SCHEMA.SVEC) 
RETURNS MADLIB_SCHEMA.SVEC AS $$
DECLARE
    new_location FLOAT[];
    new_location2 FLOAT[];
    sum FLOAT;
BEGIN
    new_location = MADLIB_SCHEMA.SVEC_return_array(p_centroid);
    sum = new_location[array_upper(new_location, 1)];
    FOR i in 1..(array_upper(new_location, 1)-1) LOOP
        new_location2[i] = new_location[i]/sum;
    END LOOP;
    RETURN MADLIB_SCHEMA.SVEC_cast_float8arr(new_location2);
END
$$ LANGUAGE plpgsql;

--! Sfunc function for _kmeans_meanPosition() aggregate.
--!
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA._kmeans_mean_product(MADLIB_SCHEMA.SVEC, MADLIB_SCHEMA.SVEC) 
RETURNS MADLIB_SCHEMA.SVEC AS $$
DECLARE
    new_location MADLIB_SCHEMA.SVEC;
BEGIN
    new_location = MADLIB_SCHEMA.SVEC_concat($2,MADLIB_SCHEMA.SVEC_cast_float8(1.0));
    IF ($1 IS NOT NULL) THEN
        new_location = $1 + new_location;
    END IF;
    RETURN new_location;
END
$$ LANGUAGE plpgsql;

--! Prefunc function for _kmeans_meanPosition() aggregate.
--!
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA._kmeans_mean_aggr(MADLIB_SCHEMA.SVEC, MADLIB_SCHEMA.SVEC) RETURNS MADLIB_SCHEMA.SVEC AS $$
DECLARE
BEGIN
    IF (($1 IS NOT NULL) AND ($2 IS NOT NULL)) THEN
        RETURN $1 + $2;
    END IF;
    IF ($1 IS NOT NULL) THEN
        RETURN $1;
    END IF;
    IF ($2 IS NOT NULL) THEN
        RETURN $2;
    END IF;
END
$$ LANGUAGE plpgsql;

--! Aggregate that computes a mean position for a set of SVECs.
--!
--! Aggregate options:
--! - stype = MADLIB_SCHEMA.SVEC
--! - sfunc = MADLIB_SCHEMA._kmeans_mean_product
--! - prefunc = MADLIB_SCHEMA._kmeans_mean_aggr
--! - finalfunc = MADLIB_SCHEMA._kmeans_mean_finalize
--!
CREATE AGGREGATE MADLIB_SCHEMA._kmeans_meanPosition( MADLIB_SCHEMA.SVEC ) 
(
  stype = MADLIB_SCHEMA.SVEC,
  sfunc = MADLIB_SCHEMA._kmeans_mean_product,
  ifdef(`GREENPLUM',`prefunc = MADLIB_SCHEMA._kmeans_mean_aggr,')
  finalfunc = MADLIB_SCHEMA._kmeans_mean_finalize
);


--! Runs the k-means algorythm (imported from kmeans.py module)
--!
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.kmeans_run( input_table text, k int, goodness int, run_id text, output_table text)
  RETURNS text
AS $$

  from madlib import kmeans

  plpy.execute( 'set client_min_messages=warning');
  return kmeans.kmeans_run( input_table, k, goodness, run_id, output_table);
 
$$ LANGUAGE plpythonu;

COMMIT;