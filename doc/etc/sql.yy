/* -----------------------------------------------------------------------------
 * sql.yy
 * 
 * A simple context-free grammar to parse SQL files and translating
 * CREATE FUNCTION statements into C++ function declarations.
 * This allows .sql files to be documented by documentation tools like Doxygen.
 *
 * Revision History:
 * 0.2: Florian Schoppmann, 16 Jan 2011, Converted to C++
 * 0.1:          "        , 10 Jan 2011, Initial version.
 * -----------------------------------------------------------------------------
 */

/* The %code directive needs bison >= 2.4 */
%require "2.4"

%code requires {
//	#include <stdio.h>
	#include <map>
	#include <fstream>
	#include <string>
	
	/* FIXME: We should not disable warning. Problem, however: asprintf */
	#pragma GCC diagnostic ignored "-Wwrite-strings"
	
	#ifdef COMPILING_SCANNER
		/* Flex expects the signature of yylex to be defined in the macro
		 * YY_DECL. */
		#define YY_DECL										\
			int												\
			bison::SQLScanner::lex(							\
				bison::SQLParser::semantic_type *yylval,	\
				bison::SQLParser::location_type *yylloc,	\
				bison::SQLDriver *driver					\
			)
	#else
		/* In the parser, we need to call the lexer and therefore need the
		 * lexer class declaration. */
		#define yyFlexLexer SQLFlexLexer
		#undef yylex
		#include "FlexLexer.h"
		#undef yyFlexLexer
	#endif
	
	/* FIXME: Remove if no longer necessary. */
	/* Data type of semantic values */
	// #define YYSTYPE char *
	
	namespace bison {

	/* Forward declaration because referenced by generated class declaration
	 * SQLParser */
	class SQLDriver;
	
	}
}

%code provides {
	namespace bison {

	class SQLScanner;

	class SQLDriver
	{
	public:
		SQLDriver();
		virtual ~SQLDriver();
		void error(const SQLParser::location_type &l, const std::string &m);
		void error(const std::string &m);

		
		std::map<std::string, char *>	fnToReturnType;
		SQLScanner						*scanner;
	};
	
	/* We need to subclass because SQLFlexLexer's yylex function does not have
	 * the proper signature */
	class SQLScanner : public SQLFlexLexer
	{
	public:
		SQLScanner(std::istream *arg_yyin = 0, std::ostream* arg_yyout = 0);
		virtual ~SQLScanner();
		static inline char *strlowerdup(const char *inString);
		virtual int lex(SQLParser::semantic_type *yylval,
			SQLParser::location_type *yylloc, SQLDriver *driver);
		virtual void preScannerAction(SQLParser::semantic_type *yylval,
			SQLParser::location_type *yylloc, SQLDriver *driver);
	};
	
	class TaggedStr
	{
	public:
		TaggedStr(int inTag, char *inStr) : tag(inTag), str(inStr) { };
		virtual ~TaggedStr() { };
	
		int		tag;
		char	*str;
	};
	
	} // namespace bison

	/* "Connect" the bison parser in the driver to the flex scanner class
	 * object. The C++ scanner generated by flex is a bit ugly, therefore
	 * this sort of hack here.
	 */
	#undef yylex
	#define yylex driver->scanner->lex
}

/* write out a header file containing the token defines */
%defines

/* use C++ and its skeleton file */
%skeleton "lalr1.cc"

/* keep track of the current position within the input */
%locations

/* The name of the parser class. */
%define "parser_class_name" "SQLParser"

/* Declare that an argument declared by the braced-code `argument-declaration'
 * is an additional yyparse argument. The `argument-declaration' is used when
 * declaring functions or prototypes. The last identifier in
 * `argument-declaration' must be the argument name. */
%parse-param { SQLDriver *driver }

/* Declare that the braced-code argument-declaration is an additional yylex
 * argument declaration. */
%lex-param   { SQLDriver *driver }

/* namespace to enclose parser in */
%name-prefix="bison"

%union
{
	char			*str;
	class TaggedStr	*tStr;
	int				i;
}

%token			END		0	"end of file"
%token <str>	IDENTIFIER	"identifier"

%token <str>	COMMENT

%token			CREATE_FUNCTION
%token			CREATE_AGGREGATE

/* Function tokens */
%token			IN
%token			OUT
%token			INOUT

%token			RETURNS
%token			SETOF

%token			AS
%token			LANGUAGE
%token			IMMUTABLE
%token			STABLE
%token			VOLATILE
%token			CALLED_ON_NULL_INPUT
%token			RETURNS_NULL_ON_NULL_INPUT
%token			SECURITY_INVOKER
%token			SECURITY_DEFINER

/* Aggregate tokens */
%token	<i>		SFUNC
%token	<i>		PREFUNC
%token	<i>		FINALFUNC
%token			SORTOP
%token			STYPE
%token			INITCOND

/* types with more than 1 word */
%token			BIT
%token			CHARACTER
%token			DOUBLE
%token			PRECISION
%token			TIME
%token			VARYING 
%token			VOID
%token			WITH
%token			WITHOUT 
%token			ZONE

%token	<str>	INTEGER_LITERAL
%token	<str>	STRING_LITERAL

%type	<str>	qualifiedIdent
%type	<str>	optFnArgList fnArgList fnArgument
%type	<str>	optAggArgList aggArgList aggArgument
%type	<str>	argname	type baseType optLength optArray array
%type	<str>	returnDecl retType
%type	<tStr>	aggOptionList aggOption
%type	<i>		aggFunc

%% /* Grammar rules and actions follow. */

input:
	| input stmt
	| input COMMENT { std::cout << $2; }
	| input '\n' { std::cout << '\n'; }
;

stmt:
	  ';'
	| createFnStmt ';' { std::cout << ";\n\n"; }
	| createAggStmt ';' { std::cout << ";\n\n"; } 
;

createFnStmt:
	  CREATE_FUNCTION qualifiedIdent '(' optFnArgList ')' returnDecl fnOptions {
		std::cout << $6 << ' ' << $2 << '(' << $4 << ") { }";
		driver->fnToReturnType.insert(std::pair<std::string,char *>($2, $6));
	}
;

createAggStmt:
	  CREATE_AGGREGATE qualifiedIdent '(' optAggArgList ')' '(' aggOptionList ')' {
		printf("@aggregate %s %s (%s) { }", $7 == NULL ? "" : $7->str, $2, $4);
	}
;

qualifiedIdent:
	  IDENTIFIER
	| IDENTIFIER '.' IDENTIFIER {
		$$ = $3;
		/* asprintf(&($$), "%s::%s", $1, $3); */
	}
;

optFnArgList: { $$ = ""; }
	| fnArgList
;

optAggArgList:
	  '*' { $$ = ""; }
	| aggArgList
;

fnArgList:
	  fnArgList ',' fnArgument {
		asprintf(&($$), "%s, %s", $1, $3);
	}
	| fnArgument
;

aggArgList:
	  aggArgList ',' aggArgument {
		asprintf(&($$), "%s, %s", $1, $3);		
	}
	| aggArgument

fnArgument:
	  type
	| argname type {
		asprintf(&($$), "%s %s", $2, $1);
	}
	| argmode argname type {
		asprintf(&($$), "%s %s", $3, $2);
	}
;

aggArgument:
	  type
	| argname type {
		asprintf(&($$), "%s %s", $2, $1);
	}
;

argmode:
	  IN
	| OUT
	| INOUT
;

argname:
	IDENTIFIER
;

type:
	  baseType optArray {
		asprintf(&($$), "%s%s", $1, $2);
	}
;

baseType:
	  qualifiedIdent
	| BIT VARYING optLength {
		asprintf(&($$), "varbit%s", $3);
	}
	| CHARACTER VARYING optLength {
		asprintf(&($$), "varchar%s", $3);
	}
	| DOUBLE PRECISION { $$ = "float8"; }
	| VOID { $$ = "void"; }
;

optArray: { $$ = ""; }
	| array;

optLength: { $$ = ""; }
	| '(' INTEGER_LITERAL ')' {
		asprintf(&($$), "(%s)", $2);
	}
;

array:
	  '[' ']' { $$ = "[]"; }
	| '[' INTEGER_LITERAL ']' {
		asprintf(&($$), "[%s]", $2);
	}
	| array '[' ']' {
		asprintf(&($$), "%s[]", $1);
	}
	| array '[' INTEGER_LITERAL ']' {
		asprintf(&($$), "%s[%s]", $1, $3);
	}
;

returnDecl: { $$ = "void"; }
	| RETURNS retType { $$ = $2; }
;

retType:
	  type
	| SETOF type {
		asprintf(&($$), "set<%s>", $2);
	}
;

fnOptions:
	| fnOptions fnOption;

fnOption:
	  AS STRING_LITERAL
	| AS STRING_LITERAL ',' STRING_LITERAL
	| LANGUAGE STRING_LITERAL
	| LANGUAGE IDENTIFIER
	| IMMUTABLE
	| STABLE
	| VOLATILE
	| CALLED_ON_NULL_INPUT
	| RETURNS_NULL_ON_NULL_INPUT
	| SECURITY_INVOKER
	| SECURITY_DEFINER
;

aggOptionList:
	  aggOptionList ',' aggOption {
		if ($1 == NULL)
			$$ = $3;
		else if ($3 == NULL)
			$$ = $1;
		else if ($1->tag == token::FINALFUNC)
			$$ = $1;
		else
			$$ = $3;
	}
	| aggOption
;

aggOption:
	  aggFunc '=' qualifiedIdent {
		$$ = new TaggedStr($1, driver->fnToReturnType[$3]);
	}
	| STYPE '=' type { $$ = new TaggedStr(token::STYPE, $3); }
	| INITCOND '=' value { $$ = NULL; }
	/* FIXME: SORTOP not yet supported at this point */
;

aggFunc:
	  SFUNC
	| PREFUNC
	| FINALFUNC
;

value:
	  INTEGER_LITERAL
	| STRING_LITERAL
	/* FIXME: Support more or ignore completely */
;

%%

namespace bison{

SQLDriver::SQLDriver() {
}

SQLDriver::~SQLDriver() {
}

void SQLDriver::error(const SQLParser::location_type &l, const std::string &m) {
	std::cerr << l << ": " << m << std::endl;
}

void SQLDriver::error(const std::string &m) {
	std::cerr << m << std::endl;
}

void SQLParser::error(const SQLParser::location_type &l,
	const std::string &m) {
	
	driver->error(l, m);
}

} // namespace bison

/* This implementation of SQLFlexLexer::yylex() is required because it is
 * declared in FlexLexer.h. The scanner's "real" yylex function is generated by
 * flex and "connected" via YY_DECL. */
#ifdef yylex
	#undef yylex
#endif
int SQLFlexLexer::yylex()
{
	std::cerr <<
		"Error: SQLFlexLexer::yylex() was called. Use SQLScanner::lex() instead"
		<< std::endl;
	return 0;
}

int	main(int argc, char **argv)
{
	std::istream		*inStream = 0;
	
	if (argc > 1)
		inStream = new std::ifstream(argv[1]);
	
	bison::SQLDriver	driver;
	bison::SQLScanner	scanner(inStream); driver.scanner = &scanner;
	bison::SQLParser	parser(&driver);

	int result = parser.parse();
	
	if (argc > 1)
		delete inStream;

	if (result != 0)
		return result;
	
	std::cout << "// List of functions:\n";
	for (std::map<std::string,char *>::iterator it = driver.fnToReturnType.begin();
		it != driver.fnToReturnType.end(); it++)
		std::cout << "// " << (*it).first << ": return type " << (*it).second << std::endl;
	
	return 0;
}
